var Spatial  = require('../components/Spatial.js');
var Position = require('../components/Position.js');
var Camera   = require('../components/Camera.js');
var QuadTree = require('../../util/QuadTree.js');
var Vec2     = require('../../util/Vec2.js');

module.exports = (function() {

  TreeMaintainer.spatialFilter = [Spatial];

  // System taht updates the spatial partioning every frame
  function TreeMaintainer()
  {
    this.tree = new QuadTree();
  }

  // Insert any new entities into the spatial tree, and re-insert any
  // entities that are no longer valid. Also update the tree's spatial size
  TreeMaintainer.prototype.update = function(dt, time)
  {
    var entities = this.entityManager.getEntitiesByComponents(
      TreeMaintainer.spatialFilter);

    this.getSize(entities);

    // Insert everything
    var size = Vec2.aquire();
    for (var n = 0; n < entities.length; n++) {
      var entity = entities[n];

      // Position and size of this entity-- use Position component
      // factoring in offset from size
      var pos = Position.getAbsoluteLocation(entity);
      size.set(entity.Spatial.size, entity.Spatial.size);
      pos.sub(size);
      size.smult(2);

      // If it's already in the tree, let's just check if we need to put
      // it in somewhere else by updating the position (which is the
      // objects center position minus half the size)
      var oldEntry = entity.Spatial._entry;
      if (oldEntry) {
        oldEntry.position.assign(pos);
        if (!this.tree.isEntryStillGood(oldEntry)) {
          this.tree.reinsertEntry(oldEntry);
        }

        continue;
      }

      // Insert and inject info on component
      var entry = this.tree.insert(entity, pos, size);
      entity.Spatial._entry = entry;
      entity.Spatial._tree  = this.tree;
    }

    Vec2.release(size);
  };

  // Determine size of the entire bounding space.
  TreeMaintainer.prototype.getSize = function(entities)
  {
    var a = 0;
    var b = 0;
    var c = 0;
    var d = 0;

    var entity, pos, size;
    for (var n = 0; n < entities.length; n++) {
      entity = entities[n];
      pos    = Position.getAbsoluteLocation(entity);
      size   = entity.Spatial.size || 1;

      if (pos.y - size < a) a = pos.y - size;
      if (pos.x + size > b) b = pos.x + size;
      if (pos.y + size > c) c = pos.y + size;
      if (pos.x - size < d) d = pos.x - size;
    }

    var padPer = 0.10;
    var pad    = Math.max((b-d)*padPer, (c-a)*padPer);
    var xSize  = b - d + pad;
    var ySize  = c - a + pad;
    var xPos   = d - pad / 2;
    var yPos   = a - pad / 2;

    var currentSize = this.tree.size;
    var currentPos = this.tree.position;

    var resize = false;

    this.tree.size.set(xSize, ySize);
    this.tree.position.set(xPos, yPos);
  };

  return TreeMaintainer;

})();
