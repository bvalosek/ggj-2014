var Position = require('../components/Position.js');
var Camera   = require('../components/Camera.js');
var Sprite   = require('../components/Sprite.js');
var Vec2     = require('../..//util/Vec2.js');
var QuadTree = require('../..//util/QuadTree.js');

module.exports = (function() {

    Renderer.spriteFilter = [Sprite, Position];
    Renderer.cameraFilter = [Camera, Position];

    // System that draws primatives onto the screen
    function Renderer()
    {
    }

    // Draw all of the cameras onto their contexts
    Renderer.prototype.update = function(dt, time)
    {
        var cameras = this.entityManager
            .getEntitiesByComponents(Renderer.cameraFilter);

        // Loop over all cameras and draw to their context
        for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            camera.Camera.entityCount = 0;
            this._drawCamera(camera);
        }
    };

    // Draw all the possible things we can onto a camera's context
    Renderer.prototype._drawCamera = function(entity)
    {
        var canvas = entity.Camera.canvas;

        // Draw Sprites
        var sprites = this.entityManager
            .getEntitiesByComponents(Renderer.spriteFilter);

        var size   = Vec2.aquire();
        var offset = Vec2.aquire();
        var v      = Vec2.aquire();
        var spriteSize = Vec2.aquire();

        var screenPos = Camera.getScreenOffset(entity).smult(-1);
        var screenSize = Camera.getScreenSize(entity);

        for (var j = 0; j < sprites.length; j++) {
            var sprite      = sprites[j];
            var spritePos   = Position.getAbsoluteLocation(sprite);
            var spriteScale = Position.getAbsoluteScale(sprite);

            // Size
            v.set(
              spriteScale.x * sprite.Sprite.resource.size.x,
              spriteScale.y * sprite.Sprite.resource.size.y
            );

            // Calculate rotated sprites AABB to determine if we need to
            // actually draw it
            Vec2.calcRectAABB(
                v,
                sprite.Sprite.resource.offset,
                sprite.Position.rotation,
                size, offset);

            // In the camera field? v = sprite's actual position
            v.assign(spritePos).sub(offset);

            var overlap = Vec2.rectIntersect(screenPos, screenSize, v, size);

            if (!overlap)
                continue;

            entity.Camera.entityCount++;

            // Convert to the screen's vector and draw it on the canvas
            Camera.toScreenVector(entity, spritePos);
            canvas
                .save()
                .scale(entity.Camera.scale, entity.Camera.scale)
                .vtranslate(spritePos)
                .rotate(Position.getAbsoluteRotation(sprite))
                .vscale(spriteScale)
                .drawImage(
                    sprite.Sprite.resource.image,
                    sprite.Sprite.resource.offset)
                .restore();

            // DEBUG -- draw AABB
            /*
            canvas
                .save()
                .scale(entity.Camera.scale, entity.Camera.scale)
                .vtranslate(spritePos.sub(offset))
                .drawRectangle(size, {
                    fill: null,
                    stroke: '#ff0fff',
                    strokeWidth: 1 / entity.Camera.scale
                })
                .restore();
            */
        }

        Vec2.release(v);
        Vec2.release(size);
        Vec2.release(offset);
        Vec2.release(spriteSize);
    };

    return Renderer;

})();
