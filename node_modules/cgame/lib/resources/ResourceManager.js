var Assembly = require('./Assembly.js');
var Resource = require('./Resource.js');
var Sprite   = require('./Sprite.js');
var Vec2     = require('../util/Vec2.js');

module.exports = (function() {

  ResourceManager.SPRITE_TAG = 'sprite';

  // Transorm a key/value pair when the key starts with a $
  ResourceManager.transforms = {
    Vec2: function(node, key, x, y) {
      return new Vec2(+x, +y);
    },
    resource: function(node, key, name) {
      this._lookups.push({
        node: node, key: key, name: name
      });
    }
  };

  // All resource managers can instantiate these types. More can be added
  ResourceManager.defaultTypes = [Assembly, Sprite];

  // Manage and load various types of resources
  function ResourceManager()
  {
    // Resource namespace tree
    this.resources   = {};

    this._tagMap = {};
    this._typeMap = {};
    this._lookups = [];

    // Types of objects we can intantiate
    var dTypes = ResourceManager.defaultTypes;
    this.Types = {};
    for (var n = 0; n < dTypes.length; n++) {
      var Type = dTypes[n];
      this.Types[Type.name] = Type;
    }

    // Downloading stuff
    this.loadedCount = 0;
    this.errorCount  = 0;
    this._queue = [];
  }

  // Let the resource manager load more types by specifing the type in the
  // resource tree with the key _T
  ResourceManager.prototype.registerType = function(T)
  {
    this.Types[T.name] = T;
  };

  // Given a json-ish hash of a resource, add it to the manager and index it
  // for accessing
  ResourceManager.prototype.registerResource = function(resource)
  {
    var res = this._parse(resource);

    var t = res.constructor.name;
    this._typeMap[t] = this._typeMap[t] || [];
    this._typeMap[t].push(res);

    this._indexTags(res);
    this._addToTree(res);
    return res;
  };

  // Return all resources tagged or an empty array
  ResourceManager.prototype.getResourceByTag = function(tag)
  {
    return this._tagMap[tag] || [];
  };

  // Return all resources of a specific type (Sprite, Assembly, etc)
  ResourceManager.prototype.getResourceByType = function(T)
  {
    return this._typeMap[T.name] || [];
  };

  // Get a specificly-name resource
  ResourceManager.prototype.getResourceByName = function(name)
  {
    var parts = name.split('.');
    var node = this.resources;
    for (var n = 0; n < parts.length; n++) {
      var part = parts[n];
      if (!node) return null;
      node = node[part];
    }

    return node;
  };

  // Second pass to resolve any resources that are referencing others
  ResourceManager.prototype.resolveReferences = function()
  {
    for (var n = 0; n < this._lookups.length; n++) {
      var lookup = this._lookups[n];
      var res = this.getResourceByName(lookup.name);
      if (!res) throw 'Cannot resolve resource: ' + lookup.name;
      lookup.node[lookup.key] = res;
    }
  };

  // Iterate over any resources that need downloading and do the damn thing
  ResourceManager.prototype.downloadResources = function(cb)
  {
    var count  = 0;
    var errors = 0;

    this._queueDownloads();

    cb = cb || function() {};

    // Callbacks
    var _this = this;
    var incLoaded = function() {
      _this.loadedCount++;
      if (_this.isDone()) cb(_this);
    };

    var incError = function() {
      _this.errorCount++;
      if (_this.isDone()) cb(_this);
    };

    for (var n = 0; n < this._queue.length; n++) {
      var item = this._queue[n];
      var path = item.path;
      var img = item.image;
      img.addEventListener('load', incLoaded);
      img.addEventListener('error', incError);
      img.src = path;
    }
  };

  // Returns true if all resources have attempted to be loaded
  ResourceManager.prototype.isDone = function()
  {
    return this._queue.length == this.loadedCount + this.errorCount;
  };


  // Recursively parse out info
  ResourceManager.prototype._parse = function(node)
  {
    var obj;
    if (node._T) {
      obj = new this.Types[node._T]();
    } else {
      obj = {};
    }

    for (var key in node) {
      if (key[0] == '_') continue;

      var value = node[key];

      // Array
      if (Object.prototype.toString.call(value) == '[object Array]') {

        // Nested
      } else if (Object(value) === value) {
        value = this._parse(value);

        // Transform required?
      } else if (key[0] === '$') {
        key = key.substring(1);
        value = this._parseObject(obj, key, value);
      }

      obj[key] = value;
    }

    return obj;
  };

  // Add anything that needs downloading to a queue
  ResourceManager.prototype._queueDownloads = function()
  {
    // Sprites
    var sprites = this.getResourceByType(Sprite);
    for (var n = 0; n < sprites.length; n++) {
      var sprite = sprites[n];
      if (sprite.imagePath)
        this._queue.push({
          path: sprite.imagePath,
          image: sprite.image
        });
    }
  };

  // Parse a given string into an object
  ResourceManager.prototype._parseObject = function(node, key, str)
  {
    var parts = str.split(' ');
    var f = ResourceManager.transforms[parts[0]];
    var args = parts.slice(1);
    args = [node, key].concat(args);
    return f.apply(this, args);
  };

  ResourceManager.prototype._addToTree = function(resource)
  {
    var parts = resource.getFullName().split('.');

    var node = this.resources;
    var part;
    for (var n = 0; n < parts.length - 1; n++) {
      part = parts[n];
      node[part] = node[part] || {};
      node = node[part];
    }

    var lastPart = parts[parts.length - 1];
    node[lastPart] = resource;
  };

  ResourceManager.prototype._indexTags = function(resource)
  {
    var index = this._tagMap;
    for (var n = 0; n < resource.tags.length; n++) {
      var tag = resource.tags[n];
      index[tag] = index[tag] || [];
      index[tag].push(resource);
    }
  };

  return ResourceManager;

})();
