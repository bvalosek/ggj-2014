var Game          = require('../Game.js');
var EntityManager = require('../ecs/EntityManager.js');
var Style         = require('../renderer/Style.js');
var Pool          = require('../util/Pool.js');
var Vec2          = require('../util/Vec2.js');
var Camera = require('../ecs/components/Camera.js');

module.exports = (function() {

  // Overlay info onto the screen
  function DebugLayer()
  {
    this.screen     = Game.instance.screen;
    this.inputs     = Game.instance.input.inputs;
    this.treeSystem = null;
  }

  // Number of items given out and free in the pool
  getTotalSize = function()
  {
    var acc = 0;
    for (var n = 0; n < Pool.pools.length; n++) {
      var pool = Pool.pools[n];
      acc += pool.count;
    }

    return acc;
  };

  // Number of free items remaining in this pool
  getTotalFree = function()
  {
    var acc = 0;
    for (var n = 0; n < Pool.pools.length; n++) {
      var pool = Pool.pools[n];
      acc += pool.freeList.length;
    }

    return acc;
  };

  var _fps = 0, _util = 0;
  var smoothing = 0.16;
  DebugLayer.prototype.update = function(dt, time)
  {
    var s = '';
    var camera = this.entityManager.getEntityByTag('mainCamera');
    var systemManager = this.entityManager.systemManager;


    if (Game.instance.lastFrameTime && Game.instance.loopTime) {
      _util =
      smoothing/10 * (Game.instance.loopTime / (1000/60) * 100) +
        (1-smoothing/10) * _util;

      _fps =
      smoothing * (1000/Game.instance.lastFrameTime) +
        (1-smoothing) * _fps;
    }

    s += 'entites=' + EntityManager.getGlobalCount() + ' ';
    s += 'fps=' + _fps.toFixed(0) + ' ';
    s += 'util=' + _util.toFixed(0) + '% ';
    s += 'drawn=' + camera.Camera.entityCount + ' ';
    s += 'events=' + systemManager.totalTriggers + ' ';

    this.screen.save();
    this.screen.translate(5, 5).drawText(s, _style);
    s = '';

    var total = getTotalSize();
    var free = getTotalFree();
    var used = total - free;

    s += 'poolUsed=' + used + ' ';
    s += 'poolCount=' + total + ' ';
    s += 'poolFree=' + free + ' ';

    this.screen
    .translate(0, 18)
    .drawText(s, _style);

    s = '';
    for (var key in this.inputs) {
      if (key == 'hover_m') continue;
      if (key == 'gamepads') {
        for (var n = 0; n < this.inputs.gamepads.length; n++) {
          var pad = this.inputs.gamepads[n];
          if (!pad) continue;

          for (var k = 0; k < pad.buttons.length; k++) {
            var val = pad.buttons[k];
            if (val) s += 'pad' + n + '_button' + k + '=' + val + ' ';
          }

          for (k = 0; k < pad.axes.length; k++) {
            var ax = pad.axes[k];
            if (Math.abs(ax) > 0.05) s += 'pad' + n + '_axes' + k + '=' + ax.toFixed(2) + ' ';
          }

        }
        continue;
      }

      var input = this.inputs[key];
      s += key + '=' + input + ' ';
    }

    this.screen.translate(0, 18).drawText(s, _style);

    this.screen.restore();

    /*
    this.drawTree();
    this.drawSpatials();
    */

  };

  // DEBUG - Draw the Spatial bounds of an entity
  DebugLayer.prototype.drawSpatials = function()
  {
    // Main camera
    var cameraEntity = this.entityManager.getEntityByTag('mainCamera');
    var canvas       = cameraEntity.Camera.canvas;
    var screenSize   = Camera.getScreenSize(cameraEntity);
    var screenPos    = Vec2.aquire()
    .assign(Camera.getScreenOffset(cameraEntity))
    .smult(-1);

    // Get all entities contained in the camera's space
    var entries = this.tree.getEntries(screenPos, screenSize);

    var pos = Vec2.aquire();
    for (var n = 0; n < entries.length; n++) {
      var entry = entries[n];
      var entity = entry.obj;

      // DEBUG -- draw AABB
      Camera.toScreenVector(cameraEntity, pos.assign(entry.position));
      canvas
        .save()
        .scale(cameraEntity.Camera.scale, cameraEntity.Camera.scale)
        .vtranslate(pos)
        .drawRectangle(entry.size, {
          fill: null,
          stroke: '#ffff00',
          strokeWidth: 1 / cameraEntity.Camera.scale
        })
        .restore();
    }

    Vec2.release(pos);
    Vec2.release(screenPos);
  };

  var _style = new Style();
  _style.font = '16px arial';
  _style.color = 'white';
  _style.stroke = null;

  // Debug, draw the tree on the main camera
  DebugLayer.prototype.drawTree = function(tree)
  {
    tree = tree || this.tree;

    // Get main camera
    var cameraEntity = this.entityManager.getEntityByTag('mainCamera');
    var canvas = cameraEntity.Camera.canvas;

    var pos = Vec2.aquire();

    canvas.save()
    .scale(cameraEntity.Camera.scale, cameraEntity.Camera.scale);

    Camera.toScreenVector(cameraEntity, pos.assign(tree.position));

    canvas.vtranslate(pos).drawRectangle(tree.size, {
      fill: null,
      stroke: 'green',
      strokeWidth: 1 / cameraEntity.Camera.scale
    });

    canvas.restore();
    Vec2.release(pos);

    var t;
    for (var x = 0; x < tree.nodes.length; x++) {
      t = tree.nodes[x];
      this.drawTree(t);
    }

  };

  return DebugLayer;

})();
