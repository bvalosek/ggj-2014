var Entity = require('./Entity.js');
var Log    = require('../util/Log.js');
var Pool   = require('../util/Pool.js');

module.exports = (function() {

  // Manage entities, systems, and components. Allows for fast and heap-free
  // access to various combinations of components and their entities
  //
  // This is the class responsible for changing all the parts of the entity
  // in order to keep everything in sync
  function EntityManager()
  {
    this.nextId = 0;
    this.entities = [];

    this._componentMap = {};

    // Injected by system manager
    this.systemManager = null;

    // DAT MEMORY POOLING BRAH
    this.entityPool = new Pool(Entity);

    // Pool all components as well
    this.componentPools = {};

    // Map of "Comp1Comp2Comp3..." -> [e1, e2, e3, ..]
    this.groupToEntitiesInfoMap = {};

    // Map of "tag" -> [e1, e2, e3]
    this.tagToEntitiesMap = {};
  }

  // Global entity count
  var globalCount = 0;

  EntityManager.getGlobalCount = function()
  {
    return globalCount;
  };

  // Get entities matching certain conditions
  EntityManager.prototype.getEntitiesByComponents = function(Components)
  {
    var key = this._groupKey(Components);
    var info = this.groupToEntitiesInfoMap[key];

    if (!info) {
      Log.w('Query on non-indexed group: ' + key);
      info = this._createNewIndex(Components);
    }

    return info ? info.entities : null;
  };

  // Get entities matching tags
  EntityManager.prototype.getEntitiesByTag = function(tag)
  {
    return this.tagToEntitiesMap[tag];
  };

  // Return first entiy with a tag
  EntityManager.prototype.getEntityByTag = function(tag)
  {
    return this.tagToEntitiesMap[tag][0];
  };

  // Construct an Entity object and add it to our set, adding all
  EntityManager.prototype.addNewEntity = function(Components)
  {
    var entity = this.entityPool.aquire();

    // Inject
    entity.id = this.nextId++;
    entity._manager = this;

    this.entities.push(entity);

    globalCount++;
    return entity;
  };

  // Construct entity from assembly
  EntityManager.prototype.addNewAssembly = function(assembly)
  {
    var entity = this.addNewEntity();

    // Add components
    for (var n = 0; n < assembly.components.length; n++) {
      var t = assembly.components[n];
      var T = this._componentMap[t];
      if (!T) throw 'Cannot resolve component: ' + t;
      entity.addComponent(T);
    }

    // Init values
    for (var C in assembly.config) {
      var configs = assembly.config[C];
      for (var key in configs) {
        entity[C][key] = configs[key];
      }
    }

    return entity;
  };

  EntityManager.prototype.registerComponent = function(Component)
  {
    this._componentMap[Component.name] = Component;
  };

  EntityManager.prototype.hasEntity = function(entity)
  {
    return !!~this.entities.indexOf(entity);
  };

  // Remove an entity and ensure all indexes are updated
  EntityManager.prototype.removeEntity = function(entity)
  {
    var index = this.entities.indexOf(entity);

    if (!~index)
      throw 'Tried to remove an entity that isnt in the list';

    // Remove from big list
    this.entities.splice(index, 1);
    globalCount--;

    // prevent access to manager
    entity._manager = null;

    // Clear tags
    entity._tags = [];
    for (var tag in this.tagToEntitiesMap) {
      var entities = this.tagToEntitiesMap[tag];

      if ( ~(index = entities.indexOf(entity)) )
        entities.splice(index, 1);
    }

    // Clear out indexes on component groups
    for (var group in this.groupToEntitiesInfoMap) {
      var info = this.groupToEntitiesInfoMap[group];

      // If this entity is supposed to be in the set, remove
      if (!entity.hasAllComponents(info.Components))
        continue;

      var loc = info.entities.indexOf(entity);
      if (~loc)
        info.entities.splice(loc, 1);
    }

    // Release all components
    for (var n = 0; n < entity._Components.length; n++) {
      var T = entity._Components[n];
      this.releaseComponent(entity[T.name]);
    }

    // Release from pool
    this.entityPool.release(entity);
  };

  // Add a text tag to an entity
  EntityManager.prototype.tagEntity = function(entity, tag)
  {
    var entities = this.tagToEntitiesMap[tag];

    if (!entities)
      entities = this.tagToEntitiesMap[tag] = [];

    // Don't add if already there
    if (~entities.indexOf(entity)) return;

    entities.push(entity);
    entity._tags.push(tag);
  };

  // Remove a tag from an entity
  EntityManager.prototype.removeEntityTag = function(entity, tag)
  {
    var entities = this.tagToEntitiesMap[tag];
    if (!entities) return;

    var index = entities.indexOf(entity);
    if (!~index) return;

    entities.splice(index, 1);
    entity._tags.splice(entity._tags.indexOf(tag), 1);
  };

  EntityManager.prototype.aquireComponent = function(T)
  {
    if (!this.componentPools[T.name])
      this.componentPools[T.name] = new Pool(T);

    return this.componentPools[T.name].aquire();
  };

  EntityManager.prototype.releaseComponent = function(component)
  {
    if (component.onRemove) component.onRemove();
    var pool = this.componentPools[component.constructor.name];
    pool.release(component);
  };

  // Add an additional component to an entity, and iterate over existing
  // group indexes to see if we need to add it to any of them
  EntityManager.prototype.addEntityComponent = function(
  entity, Component, opts)
  {
    if (~entity._Components.indexOf(Component))
      throw 'Cannot add multiple Components of the same type';

    entity._Components.push(Component);

    var component = entity[Component.name] =
    this.aquireComponent(Component);

    // Initial config
    if (opts)
      for (var key in opts)
        component[key] = opts[key];

      // Check each index to see if we need to update it
      for (var group in this.groupToEntitiesInfoMap) {
        var info = this.groupToEntitiesInfoMap[group];

        // If this Component is on this index, and if the entity has all
        // the Components, and if its not already in there, add it
        if (!~info.Components.indexOf(Component))
          continue;
        if (!entity.hasAllComponents(info.Components))
          continue;
        if (~info.entities.indexOf(entity))
          continue;

        info.entities.push(entity);
      }
  };

  // Remove a component from an entity
  EntityManager.prototype.removeEntityComponent = function(entity, Component)
  {
    var index = entity._Components.indexOf(Component);
    if (!~index) return;

    // Check each index to see if we need to update it
    for (var group in this.groupToEntitiesInfoMap) {
      var info = this.groupToEntitiesInfoMap[group];

      // If this Component is on this index, and if the entity has all
      // the Components, and if its on there, delete it
      if (!~info.Components.indexOf(Component))
        continue;
      if (!entity.hasAllComponents(info.Components))
        continue;

      var loc = info.entities.indexOf(entity);

      if (~loc)
        info.entities.splice(loc, 1);
    }

    // Remove the component and the information, call the release as well
    entity._Components.splice(index, 1);
    var c = entity[Component.name];
    this.releaseComponent(c);

    delete entity[Component.name];
  };

  // Creates a new index on a set of components and returns the info node
  EntityManager.prototype._createNewIndex = function(Components)
  {
    var key = this._groupKey(Components);

    if (this.groupToEntitiesInfoMap[key]) return;

    // Add in the empty index
    var info = this.groupToEntitiesInfoMap[key] = {
      Components: Components,
      entities: []
    };

    // Loop over all entities and add them in if they have any all of these
    // components
    for (var n = 0; n < this.entities.length; n++) {
      var entity = this.entities[n];

      if (entity.hasAllComponents(Components))
        info.entities.push(entity);
    }

    return info;
  };

  // Generate the stringly-type key based on a set of components
  EntityManager.prototype._groupKey = function(Components)
  {
    var names = [];
    for (var n = 0; n < Components.length; n++) {
      var Component = Components[n];
      names.push(Component.name);
    }

    return names.sort().join('');
  };

  return EntityManager;

})();
