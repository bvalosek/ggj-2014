var Vec2 = require('./Vec2.js');
var Pool = require('./Pool.js');

module.exports = (function() {

  // Max number of entries in a node before it splits
  QuadTree.MAX_ENTRIES = 15;

  // Max depth the tree will split
  QuadTree.MAX_LEVELS  = 6;

  // Effectively store positional and sized objects. Constructor is setup to
  // get pooled. Each tree has a position and size, as well as up to 4 child
  // nodes (other trees) and an array of entries.
  function QuadTree()
  {
    this.level = 0;
    this.position = Vec2.aquireOrClear(this.position);
    this.size = Vec2.aquireOrClear(this.size);
    this.nodes = this.nodes !== undefined ? this.nodes : [];
    this.entries = this.entries !== undefined ? this.entries : [];
  }

  // A single item in the tree, contiains a pointer back to the node its in
  // as well as the spatial information of where its at. Setup to be pulled.
  function Entry()
  {
    this.obj      = null;
    this.node     = null;
    this.position = Vec2.aquireOrClear(this.position);
    this.size     = Vec2.aquireOrClear(this.size);
  }

  // Static pools for trees and entrys
  var treePool  = new Pool(QuadTree);
  var entryPool = new Pool(Entry);

  // Add a new item to the tree thats already packaged into an entry
    QuadTree.prototype.insertEntry = function(entry)
  {
    // Delegate insertion to a child node if we can
    if (this.nodes.length) {
      var index = this.getIndex(entry.position, entry.size);
      if (~index) return this.nodes[index].insertEntry(entry);
    }

    this.entries.push(entry);
    entry.node = this;

    this.splitAndRedistrubuteIfNeeded();
    return entry;
  };

  // If we've overpacked this tree, then split it into 4 smaller trees and
  // redistrubute
  QuadTree.prototype.splitAndRedistrubuteIfNeeded = function()
  {
    // Split tree?
    if (this.entries.length > QuadTree.MAX_ENTRIES &&
    this.level < QuadTree.MAX_LEVELS) {
      if (!this.nodes.length)
        this.split();
      this.redistrubute();
    }
  };

  // Remove an entry from the tree (and release it back to the pool).
  // dontRelease will prevent the entry from being release (if we want to use
// it again)
    QuadTree.prototype.removeEntry = function(entry, dontRelease)
    {
      var oldNode = entry.node;
      var index = oldNode.entries.indexOf(entry);
      oldNode.entries.splice(index, 1);
      oldNode.combine();
      oldNode.splitAndRedistrubuteIfNeeded();

      if (dontRelease) return;

      entryPool.release(entry);
    };

    // Re-insert an entry in order to get it to the right place in the tree
    QuadTree.prototype.reinsertEntry = function(entry)
    {
      this.removeEntry(entry, true);
      this.insertEntry(entry);
    };

    // Returns true if the passed entry is still okay where its at. Returning
    // false means would she re-insert it into the tree in order to put it in
    // its correct place
    QuadTree.prototype.isEntryStillGood = function(entry)
    {
      var pos          = entry.position;
      var size         = entry.size;
      var node         = entry.node;
      var nodePosition = node.position;
      var nodeSize     = node.size;

      var inside = Vec2.rectContained(pos, size, nodePosition, nodeSize);

      // If no child nodes and we still fit inside, then we're good
      if (!node.nodes.length && inside)
        return true;

      // If there are child nodes and we're still in the root, and inside,
      // we're good
    else if (!~node.getIndex(pos, size) && inside)
      return true;

    return false;
    };

    // Pack into an entry and add to the tree
    QuadTree.prototype.insert = function(object, position, size)
    {
      entry = entryPool.aquire();
      entry.position.assign(position);
      entry.size.assign(size);
      entry.obj = object;
      return this.insertEntry(entry);
    };

    // Distrubute all entrys into child nodes
    QuadTree.prototype.redistrubute = function()
    {
      // Loop through all of our objects and if they can fit into a child
      // node, move them there
      var i = 0;
      while (i < this.entries.length) {
        entry = this.entries[i];
        index = this.getIndex(entry.position, entry.size);

        // Insert into child, remove from our array if they belong in
        // another node
        if (~index) {
          this.nodes[index].insertEntry(entry);
          this.entries.splice(i, 1);
        } else {
          i++;
        }
      }
    };

    // Given a position and (non-offset) side, return an array of all entries
    // that match
    QuadTree.prototype.getEntries = function(position, size, objects)
    {
      objects  = objects || [];

      // If area is in a node, get all if its entities for that node
      var index = this.getIndex(position, size);
      if (~index && this.nodes.length) {
        this.nodes[index].getEntries(position, size, objects);

        // Otherwise, add all nodes to it
      } else {
        for (var j = 0; j < this.nodes.length; j++) {
          var node = this.nodes[j];
          node.getEntries(position, size, objects);
        }
      }

      // Add everything from this node itself
      for (var m = 0; m < this.entries.length; m++) {
        var entry = this.entries[m];
        if (Vec2.rectIntersect(position, size, entry.position, entry.size))
          objects.push(entry);
      }

      return objects;
    };

    // Return which of the 4 quadrants an object would go into. -1 means it
    // would cross into multiple nodes and should be part of the parent
    QuadTree.prototype.getIndex = function(position, size)
    {
      var midX = this.position.x + this.size.x / 2;
      var midY = this.position.y + this.size.y / 2;

      var left = position.x < midX && position.x + size.x < midX;
      var right = position.x > midX;

      var top    = position.y < midY && position.y + size.y < midY;
      var bottom = position.y > midY;

      if (top && right) return 0;
      if (top && left) return 1;
      if (bottom && left) return 2;
      if (bottom && right) return 3;

      return -1;
    };

    // Empty the tree by recursively removeing nodes and entries
    QuadTree.prototype.clear = function()
    {
      // Release all entries, clear array
      for (var i = 0; i < this.entries.length; i++) {
        var entry = this.entries[i];
        entryPool.release(entry);
      }
      this.entries.length = 0;

      // Recrusively clear each node, release it back to pool, and clear our
      // node array
      for (var n = 0; n < this.nodes.length; n++) {
        var node = this.nodes[n];
        node.clear();
        treePool.release(node);
      }
      this.nodes.length = 0;
    };

    // Move all entires in child nodes to this node and remove them. Unwinds
    // what we've done so far
    QuadTree.prototype.combine = function()
    {
      for (var n = 0; n < this.nodes.length; n++) {
        var node = this.nodes[n];

        // Combine all child nodes first
        node.combine();

        // All entries are now on THIS node, clear out the entry node, and
        // release it
        for (var m = 0; m < node.entries.length; m++) {
          var entry = node.entries[m];
          this.entries.push(entry);
          entry.node = this;
        }
        node.entries.length = 0;
        node.clear();
        treePool.release(node);
      }

      // All nodes gone
      this.nodes.length = 0;
    };

    // Create 4 sub trees as the nodes for the tree
    QuadTree.prototype.split = function()
    {
      var x = this.position.x;
      var y = this.position.y;
      var w = this.size.x / 2;
      var h = this.size.y / 2;

      var node;
      for (n = 0; n < 4; n++) {
        node = treePool.aquire();
        node.level = this.level + 1;
        node.size.set(w, h);

        switch(n) {
          case 0: node.position.set(x + w, y); break; // I
          case 1: node.position.set(x, y); break; // II
          case 2: node.position.set(x, y + h); break; // III
          case 3: node.position.set(x + w, y + h); break; // VI
        }

        this.nodes.push(node);
      }
    };

    return QuadTree;

})();
