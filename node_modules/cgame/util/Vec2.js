var Pool = require('../util/Pool');

// 2D vector with floating point component values
module.exports = (function() {

  // Legit pool
  var pool = Vec2._pool = new Pool(Vec2);
  Vec2.aquire = function() { return pool.aquire(); };
  Vec2.release = function(x) { return pool.release(x); };

  Vec2.aquireOrClear = function(x) {
    if (x) return x.clear();
    return Vec2.aquire();
  };

  // Ensure we get a zero vector always
  var zero = new Vec2();
  Vec2.zero = function() { return zero.set(0.0, 0.0); };

  // Ensure we always have a floating point for dimensions
  function Vec2(x, y)
  {
    this.x = +x || 0.0;
    this.y = +y || 0.0;
  }

  // Duplicate from backed pool
  Vec2.prototype.pcopy = function()
  {
    var v = Vec2.aquire();
    v.x = this.x;
    v.y = this.y;
    return v;
  };

  // Duplicate -- allocates a new object
  Vec2.prototype.copy = function()
  {
    return new Vec2(this.x, this.y);
  };

  Vec2.prototype.equals = function(v)
  {
    return this.x === v.x && this.y === v.y;
  };

  // Reset
  Vec2.prototype.clear = function()
  {
    this.x = this.y = 0.0;
    return this;
  };

  // Duplicate a source
  Vec2.prototype.assign = function(v)
  {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  /**
  * @param {Number} x x component
  * @param {Number} y y component
  */
  Vec2.prototype.set = function(x, y)
  {
    this.x = +x;
    this.y = +y;
    return this;
  };

  // Dot product
  Vec2.prototype.dot = function(v)
  {
    return +(this.x * v.x + this.y * v.y);
  };

  // Determinent
  Vec2.prototype.det = function(v)
  {
    return +(this.x * v.y - this.y * v.x);
  };

  // Vector subtraction
  Vec2.prototype.sub = function(v)
  {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  };

  // Vector addition
  Vec2.prototype.add = function(v)
  {
    this.x += v.x;
    this.y += v.y;
    return this;
  };

  // Scalar multiplication
  Vec2.prototype.smult = function(n)
  {
    n = +n;
    this.x *= n;
    this.y *= n;
    return this;
  };

  // Length of vector
  Vec2.prototype.magnitude = function()
  {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };

  // Squared length
  Vec2.prototype.magnitude2 = function()
  {
    return this.x * this.x + this.y * this.y;
  };

  /**
  * Rotate the vector by some amount.
  * @param {Number} theta Amount to rotate by.
  */
  Vec2.prototype.rotate = function(theta)
  {
    return this.set(
      this.x * Math.cos(theta) - this.y * Math.sin(theta),
      this.x * Math.sin(theta) + this.y * Math.cos(theta)
    );
  };

  /**
  * Create a new Vec2 with a certain angle and magnitude.
  * @param {Number} theta Angle of the vector
  * @param {Number} m Magnitude of the vector
  */
  Vec2.fromAngle = function(theta, m)
  {
    m = +m || 1.0;
    return new Vec2(Math.cos(theta) * m, Math.sin(theta) * m);
  };

  /**
  * Create a new Vec2 with a certain angle and magnitude. Uses the object
  * pool.
  * @param {Number} theta Angle of the vector
  * @param {Number} m Magnitude of the vector
  */
  Vec2.pfromAngle = function(theta, m)
  {
    var v = Vec2.aquire();
    m = +m || 1.0;
    v.set(Math.cos(theta) * m, Math.sin(theta) * m);
    return v;
  };

  /**
  * Return the angle created by this vector
  */
  Vec2.prototype.angle = function()
  {
    return Math.atan2(this.y, this.x);
  };

  /**
  * Get the angle between this vector an another. Will range between -PI and
  * PI.
  * @param {Vec2} v Other angle.
  */
  Vec2.prototype.angleBetween = function(v)
  {
    return Math.atan2(this.det(v), this.dot(v));
  };

  /**
  * Limit a vector to a specific magnitude
  * @param {Number} size Maximum magnitude
  */
  Vec2.prototype.limit = function(size)
  {
    size = +size;
    if (!size)
      return this;
    else if (this.magnitude() > size)
      return this.normalize(size);
    else
      return this;
  };

  // Normalize a vector (with optional scale length)
  Vec2.prototype.normalize = function(m)
  {
    m = +m || 1.0;
    var length = Math.sqrt(this.x * this.x + this.y * this.y);
    this.x = m * this.x / length;
    this.y = m * this.y / length;
    return this;
  };

  // Calculate the AABB of a rectangle specified by a single size and offset
  // vector
  Vec2.calcRectAABB = function(size, offset, rotation, out_size, out_offset)
  {
    // Trivial case -- using it for everything for now because the other
    // way is so damn slow with all of the rotations.
    if (!rotation) {
      out_size.assign(size);
      out_offset.assign(offset);
      return;
    }

    // Just make it MASSIVE
    var s = Math.max(size.x, size.y)*1.41;
    out_size.set(s, s);
    out_offset.set(s/2, s/2);
    return;
  };

  // Determine AABB size and center offset given an array of vertices and a
  // potential rotation
  Vec2.calcAABB = function(vertices, rotation, out_size, out_offset)
  {
    var v      = Vec2.aquire();
    var top    = Vec2.aquire();
    var bottom = Vec2.aquire();
    var left   = Vec2.aquire();
    var right  = Vec2.aquire();

    for (var n = 0; n < vertices.length; n++) {
      v.assign(vertices[n]).rotate(rotation);

      if (!n) {
        top.assign(v);
        bottom.assign(v);
        left.assign(v);
        right.assign(v);
        continue;
      }

      if (v.y < top.y)
        top.assign(v);
      if (v.y > bottom.y)
        bottom.assign(v);
      if (v.x < left.x)
        left.assign(v);
      if (v.x > right.x)
        right.assign(v);
    }

    out_size.set(right.x - left.x, bottom.y - top.y);
    out_offset.set(-left.x, -top.y);

    Vec2.release(v);
    Vec2.release(top);
    Vec2.release(bottom);
    Vec2.release(left);
    Vec2.release(right);
  };

  // Determine if 2 AABB rectanges defined by size and position intersect
  Vec2.rectIntersect = function(pos1, size1, pos2, size2)
  {
    var a = pos1.x + size1.x < pos2.x;
    var b = pos1.x > pos2.x + size2.x;
    var c = pos1.y + size1.y < pos2.y;
    var d = pos1.y > pos2.y + size2.y;

    return !(a || b || c || d);
  };

  // Determine if a rectangle is entirely contained by another (if 1 is
  // entirely inside 2)
  Vec2.rectContained = function(pos1, size1, pos2, size2)
  {
    if (pos1.x < pos2.x) return false;
    if (pos1.y < pos2.y) return false;
    if (pos1.x + size1.x > pos2.x + size2.x) return false;
    if (pos1.y + size1.y > pos2.y + size2.y) return false;

    return true;
  };

  Vec2.prototype.toString = function()
  {
    return '' + (this.x.toFixed(2)) + ',' + (this.y.toFixed(2));
  };

  return Vec2;

})();
